<html>
<body>
	<table id="gameField">
	</table>
	
	<p id="dataResponse"></p>
	<button onclick="calculateSolutions()">Calculate Solution(s)</button>
<script>
	let lastElement = false;
	let activeElements = 999;
	let rowCount = 5;
	let columnCount = 4;
	let emptyFields = [[true]];
	let gameField = [];


	function startGameAndCalculations() {
		buildGameField();
	}
	
	function buildGameField() {
		let gameFieldElement = document.getElementById("gameField");
		activeElements = rowCount * columnCount - emptyFields.length;
		
		//make fieldset
		for (let i = 0; i < rowCount; i++) {
			gameField[i] = [];
			for (let j = 0; j < columnCount; j++) {
				gameField[i][j] = true;
			}
		}
		
		//remove empty fields
		for (let i = 0; i < emptyFields.length; i++) {
			for (let j = 0; j < emptyFields[i].length; j++) {
				gameField[i][j] = false;
			}
		}
		
		//build the field
		let rowElement = document.createElement("tr");
		for (let i = 0; i < rowCount; i++) {
			let header = document.createElement("td");
			header.innerHTML = i - 1;
			if (i == 0) {
				header.innerHTML = "-";
			}
			rowElement.append(header);
		}
		gameFieldElement.append(rowElement);
		for (let i = 0; i < rowCount; i++) {
			rowElement = document.createElement("tr");
			let header = document.createElement("td");
			header.innerHTML = i;
			rowElement.append(header);
			for (let j = 0; j < columnCount; j++) {
				let cellElement = document.createElement("td");
				cellElement.id = i + ":" + j;
				cellElement.addEventListener("click", function(e) {
					clickHandling(e.srcElement.id);
				});
				if (gameField[i][j]) {
					cellElement.innerHTML = "o";
				} else {
					cellElement.innerHTML = "_";
				}
				
				rowElement.append(cellElement);
			}
			gameFieldElement.append(rowElement);
		}
	}
	
	function clickHandling(id) {
		if (lastElement != false) {
			let lastDimensions = lastElement.split(":");
			let currentDimensions = id.split(":");
			lastDimensions[0] = parseInt(lastDimensions[0]);
			lastDimensions[1] = parseInt(lastDimensions[1]);
			currentDimensions[0] = parseInt(currentDimensions[0]);
			currentDimensions[1] = parseInt(currentDimensions[1]);
			
			//check if move is invalid
			if (
				gameField[currentDimensions[0]][currentDimensions[1]] || 
				!gameField[lastDimensions[0]][lastDimensions[1]]
			) {
				lastElement = id;
			} else {
				
				let directions = ["above", "right", "below", "left"];
				for (let d = 0; d < directions.length; d++) {
					if (checkDimensionsOnMove(currentDimensions, lastDimensions, directions[d])) {
						console.log("checked");
						doMove(currentDimensions, lastDimensions, directions[d]);
						
						//check winning
						if (activeElements == 1) {
							alert("you won!");
						}
						
						return;
					}
				}
			}
		}
		
		lastElement = id;
	}
	
	function checkDimensionsOnMove(currentDimensions, lastDimensions, direction) {
		let [xModifier, yModifier] = getModifiers(direction);
		
		if (
			currentDimensions[0] == lastDimensions[0] + yModifier &&
			currentDimensions[1] == lastDimensions[1] + xModifier &&
			typeof(gameField[currentDimensions[0] - yModifier / 2][currentDimensions[1] - xModifier / 2]) !== "undefined" &&
			gameField[currentDimensions[0] - yModifier / 2][currentDimensions[1] - xModifier / 2]
		) {
			return true;
		}
		return false;
	}
	
	function getModifiers(direction) {
		let yModifier = 0;
		let xModifier = 0;
		
		switch(direction) {
			case "above":
					yModifier = -2;
				break;
			case "below":
					yModifier = 2;
				break;
			case "left":
					xModifier = -2;
				break;
			case "right":
					xModifier = 2;
				break;
		}
		return [xModifier, yModifier];
	}
	
	function doMove(currentDimensions, lastDimensions, direction) {
		let [xModifier, yModifier] = getModifiers(direction);
		
		gameField[currentDimensions[0]][currentDimensions[1]] = true;
		document.getElementById(currentDimensions[0] + ":" + currentDimensions[1]).innerHTML = "o";
		gameField[lastDimensions[0]][lastDimensions[1]] = false;
		document.getElementById(lastDimensions[0] + ":" + lastDimensions[1]).innerHTML = "_";
		gameField[currentDimensions[0] - yModifier / 2][currentDimensions[1] - xModifier / 2] = false;
		document.getElementById((currentDimensions[0] - yModifier / 2) + ":" + (currentDimensions[1] - xModifier / 2)).innerHTML = "_";
		activeElements--;
	}
	
	startGameAndCalculations();
	
	
	function calculateSolutions() {
		console.log("calculating...");
		activeElements = rowCount * columnCount - emptyFields.length;
		
		//make gameField - copied ( no time for clean code :( )
		let calculationField = [];
		
		//make fieldset
		for (let i = 0; i < rowCount; i++) {
			calculationField[i] = [];
			for (let j = 0; j < columnCount; j++) {
				calculationField[i][j] = true;
			}
		}
		//remove empty fields
		for (let i = 0; i < emptyFields.length; i++) {
			for (let j = 0; j < emptyFields[i].length; j++) {
				calculationField[i][j] = false;
			}
		}
		
		doCalculations(calculationField, activeElements, []);
	}
	
	function doCalculations(field, active, moves) {
		if (active == 1) {
			console.log(moves);
		} else {
			//check for field that is a valid moving target (so false)
			for (let i = 0; i < field.length; i++) {
				for (let j = 0; j < field[i].length; j++) {
					if (!field[i][j]) {
						calculateMoves(field, active, moves, i, j);
					}
				}
			}
		}
	}
	
	function calculateMoves(field, active, moves, i, j) {
		let directions = [
			[-2, 0],
			[0, -2],
			[2, 0],
			[0, 2]
		];
		for (let d = 0; d < directions.length; d++) {
			if (
				typeof(field[i + directions[d][0]]) !== "undefined" && 
				typeof(field[i + directions[d][0]][j + directions[d][1]]) !== "undefined" && 
				field[i + directions[d][0]][j + directions[d][1]] && 
				typeof(field[i + directions[d][0] / 2]) !== "undefined" && 
				typeof(field[i + directions[d][0] / 2][j + directions[d][1] / 2]) !== "undefined" && 
				field[i + directions[d][0] / 2][j + directions[d][1] / 2]
			) {
				let newField = JSON.parse(JSON.stringify(field));
				let newActive = active - 1;
				let newMoves = JSON.parse(JSON.stringify(moves));
				newField[i][j] = true;
				newField[i + directions[d][0] / 2][j + directions[d][1] / 2] = false;
				newField[i + directions[d][0]][j + directions[d][1]] = false;
				newMoves.push((i + directions[d][0]) + ":" + (j + directions[d][1]) + " TO " + i + ":" + j);
				doCalculations(newField, newActive, newMoves);
			}
		}
	}
</script>
</body>
</html>
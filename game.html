<html>
<body>
	<table id="gameField">
	</table>
	
	<p id="dataResponse"></p>
	<button onclick="calculateSolutions()">Calculate Solution(s)</button>
	<button onclick="showSolution()">Show a Solution</button>
<script>
	let lastElement = false;
	let activeElements = 999;
	let rowCount = 5;
	let columnCount = 4;
	let emptyFields = [[true]];
	let gameField = [];


	function startGameAndCalculations() {
		buildGameField();
	}
	
	function buildGameField() {
		let gameFieldElement = document.getElementById("gameField");
		activeElements = rowCount * columnCount - emptyFields.length;
		
		//make fieldset
		for (let i = 0; i < rowCount; i++) {
			gameField[i] = [];
			for (let j = 0; j < columnCount; j++) {
				gameField[i][j] = true;
			}
		}
		
		//remove empty fields
		for (let i = 0; i < emptyFields.length; i++) {
			for (let j = 0; j < emptyFields[i].length; j++) {
				gameField[i][j] = false;
			}
		}
		
		//build the field
		let rowElement = document.createElement("tr");
		for (let i = 0; i < rowCount; i++) {
			let header = document.createElement("td");
			header.innerHTML = i - 1;
			if (i == 0) {
				header.innerHTML = "-";
			}
			rowElement.append(header);
		}
		gameFieldElement.append(rowElement);
		for (let i = 0; i < rowCount; i++) {
			rowElement = document.createElement("tr");
			let header = document.createElement("td");
			header.innerHTML = i;
			rowElement.append(header);
			for (let j = 0; j < columnCount; j++) {
				let cellElement = document.createElement("td");
				cellElement.id = i + ":" + j;
				cellElement.addEventListener("click", function(e) {
					clickHandling(e.srcElement.id);
				});
				if (gameField[i][j]) {
					cellElement.innerHTML = "o";
				} else {
					cellElement.innerHTML = "_";
				}
				
				rowElement.append(cellElement);
			}
			gameFieldElement.append(rowElement);
		}
	}
	
	function clickHandling(id) {
		if (lastElement != false) {
			let lastDimensions = lastElement.split(":");
			let currentDimensions = id.split(":");
			lastDimensions[0] = parseInt(lastDimensions[0]);
			lastDimensions[1] = parseInt(lastDimensions[1]);
			currentDimensions[0] = parseInt(currentDimensions[0]);
			currentDimensions[1] = parseInt(currentDimensions[1]);
			
			//check if move is invalid
			if (
				gameField[currentDimensions[0]][currentDimensions[1]] || 
				!gameField[lastDimensions[0]][lastDimensions[1]]
			) {
				lastElement = id;
			} else {
				
				let directions = ["above", "right", "below", "left"];
				for (let d = 0; d < directions.length; d++) {
					if (checkDimensionsOnMove(currentDimensions, lastDimensions, directions[d])) {
						doMove(currentDimensions, lastDimensions, directions[d]);
						
						//check winning
						if (activeElements == 1) {
							alert("you won!");
						}
						
						return;
					}
				}
			}
		}
		
		lastElement = id;
	}
	
	function checkDimensionsOnMove(currentDimensions, lastDimensions, direction) {
		let [xModifier, yModifier] = getModifiers(direction);
		
		if (
			currentDimensions[0] == lastDimensions[0] + yModifier &&
			currentDimensions[1] == lastDimensions[1] + xModifier &&
			typeof(gameField[currentDimensions[0] - yModifier / 2][currentDimensions[1] - xModifier / 2]) !== "undefined" &&
			gameField[currentDimensions[0] - yModifier / 2][currentDimensions[1] - xModifier / 2]
		) {
			return true;
		}
		return false;
	}
	
	function getModifiers(direction) {
		let yModifier = 0;
		let xModifier = 0;
		
		switch(direction) {
			case "above":
					yModifier = -2;
				break;
			case "below":
					yModifier = 2;
				break;
			case "left":
					xModifier = -2;
				break;
			case "right":
					xModifier = 2;
				break;
		}
		return [xModifier, yModifier];
	}
	
	function doMove(currentDimensions, lastDimensions, direction) {
		let [xModifier, yModifier] = getModifiers(direction);
		
		gameField[currentDimensions[0]][currentDimensions[1]] = true;
		document.getElementById(currentDimensions[0] + ":" + currentDimensions[1]).innerHTML = "o";
		gameField[lastDimensions[0]][lastDimensions[1]] = false;
		document.getElementById(lastDimensions[0] + ":" + lastDimensions[1]).innerHTML = "_";
		gameField[currentDimensions[0] - yModifier / 2][currentDimensions[1] - xModifier / 2] = false;
		document.getElementById((currentDimensions[0] - yModifier / 2) + ":" + (currentDimensions[1] - xModifier / 2)).innerHTML = "_";
		activeElements--;
	}
	
	startGameAndCalculations();
	
	
	function calculateSolutions() {
		console.log("calculating...");
		activeElements = rowCount * columnCount - emptyFields.length;
		
		//make gameField - copied ( no time for clean code :( )
		let calculationField = [];
		
		//make fieldset
		for (let i = 0; i < rowCount; i++) {
			calculationField[i] = [];
			for (let j = 0; j < columnCount; j++) {
				calculationField[i][j] = true;
			}
		}
		//remove empty fields
		for (let i = 0; i < emptyFields.length; i++) {
			for (let j = 0; j < emptyFields[i].length; j++) {
				calculationField[i][j] = false;
			}
		}
		
		doCalculations(calculationField, activeElements, []);
	}
	
	function doCalculations(field, active, moves) {
		if (active == 1) {
			console.log(moves);
		} else {
			//check for field that is a valid moving target (so false)
			for (let i = 0; i < field.length; i++) {
				for (let j = 0; j < field[i].length; j++) {
					if (!field[i][j]) {
						calculateMoves(field, active, moves, i, j);
					}
				}
			}
		}
	}
	
	function calculateMoves(field, active, moves, i, j) {
		let directions = [
			[-2, 0],
			[0, -2],
			[2, 0],
			[0, 2]
		];
		for (let d = 0; d < directions.length; d++) {
			if (
				typeof(field[i + directions[d][0]]) !== "undefined" && 
				typeof(field[i + directions[d][0]][j + directions[d][1]]) !== "undefined" && 
				field[i + directions[d][0]][j + directions[d][1]] && 
				typeof(field[i + directions[d][0] / 2]) !== "undefined" && 
				typeof(field[i + directions[d][0] / 2][j + directions[d][1] / 2]) !== "undefined" && 
				field[i + directions[d][0] / 2][j + directions[d][1] / 2]
			) {
				let newField = JSON.parse(JSON.stringify(field));
				let newActive = active - 1;
				let newMoves = JSON.parse(JSON.stringify(moves));
				newField[i][j] = true;
				newField[i + directions[d][0] / 2][j + directions[d][1] / 2] = false;
				newField[i + directions[d][0]][j + directions[d][1]] = false;
				newMoves.push((i + directions[d][0]) + ":" + (j + directions[d][1]) + " TO " + i + ":" + j);
				doCalculations(newField, newActive, newMoves);
			}
		}
	}
	
	
	
	function showSolution() {
		let moves = [
			['2:0', '0:0'],
			['1:2', '1:0'],
			['3:1', '1:1'],
			['3:2', '1:2'],
			['0:2', '2:2'],
			['4:0', '2:0'],
			['0:0', '0:2'],
			['0:3', '0:1'],
			['4:2', '4:0'],
			['1:0', '3:0'],
			['2:3', '2:1'],
			['4:3', '2:3'],
			['4:0', '2:0'],
			['2:0', '2:2'],
			['1:3', '3:3'],
			['0:1', '2:1'],
			['2:1', '2:3'],
			['3:3', '1:3']
		]; 
 		
		let currentDelay = 0;
		
		for (let m = 0; m < moves.length; m++) {
			let sourceElement = document.getElementById(moves[m][0]);
			let targetElement = document.getElementById(moves[m][1]);
			
			let x = 999;
			let y = 999;
			if (parseInt(moves[m][0].split(":")[0]) != parseInt(moves[m][1].split(":")[0])) {
				y = parseInt(moves[m][0].split(":")[1]);
				let values = [parseInt(moves[m][0].split(":")[0]), parseInt(moves[m][1].split(":")[0])].sort();
				x = values[0] + 1;
			} else {
				x = parseInt(moves[m][0].split(":")[0]);
				let values = [parseInt(moves[m][0].split(":")[1]), parseInt(moves[m][1].split(":")[1])].sort();
				y = values[0] + 1;
			}
			
			let inbetweenElement = document.getElementById(x + ":" + y);
			
			const animationSource = [
				{ background: "#0000FF" }
			];
			const animationTarget = [
				{ background: "#00FF00" }
			];
			const animationInBetween = [
				{ background: "#FF0000" }
			];

			const animationTiming = {
			  duration: 1000,
			  delay: currentDelay,
			  iterations: 1,
			};
			
			sourceElement.style.setProperty("animation-delay", "1s");
					
			let sourceAnimation = sourceElement.animate(animationSource, animationTiming);
			let targetAnimation = targetElement.animate(animationTarget, animationTiming);
			let inbetweenAnimation = inbetweenElement.animate(animationInBetween, animationTiming);
			
			sourceAnimation.finished.then(() => {
			  sourceElement.innerHTML = "_";
			});
			targetAnimation.finished.then(() => {
			  targetElement.innerHTML = "o";
			});
			inbetweenAnimation.finished.then(() => {
			  inbetweenElement.innerHTML = "_";
			});
			
			currentDelay += 1000;
		}
	}
</script>
</body>
</html>